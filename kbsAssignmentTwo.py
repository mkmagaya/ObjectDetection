# -*- coding: utf-8 -*-
"""kbsAssignmentTwo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15WxHjzIa26YKS9DTaPSmdLdZ2XOsQ_gc

**#OBJECT DETECTION USING OPEN-CV AND VGG16 MODEL**

MAGAYA MAKOMBORERO R181571B

MABHUKA B. OSWELL  R181573F

#this project was deployed using [Streamlit Share](https://share.streamlit.io/mkmagaya/objectdetection/main/app.py)
#the project was deployed via a [GitHub repository](https://github.com/mkmagaya/objectdetection)

#challenges faced
######we did not manage to successifully deploy our application on streamlit due to limited github upload capacity

#import necessary libraries
"""

import numpy as np
# from keras.applications.vgg16 import VGG16, preprocess_input, decode_predictions
from tensorflow.keras.utils import plot_model
from tensorflow.keras.preprocessing import image
import os
import glob
import cv2
from tensorflow.keras.optimizers import Adam
from keras.preprocessing import image
import requests
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing.image import img_to_array, load_img, array_to_img
from tensorflow.keras.preprocessing import image
from keras.applications.vgg16 import VGG16, preprocess_input, decode_predictions
from tensorflow.keras.utils import plot_model
from tensorflow.keras.models import load_model
model = load_model('vgg16Model.h5')

"""#creating object for VGG16 pre-trained **model**"""

# model = VGG16(include_top=True, weights='imagenet', input_tensor=None, input_shape=None)

"""#plot model"""

plot_model(model, to_file='vgg_model.png')

"""#model summary"""

model.summary()

"""# Optimization"""

# Optimization 
# opt = Adam(1e-4)
# model.compile(loss='mse',optimizer=opt)

"""#saving the VGG16 model """

# model.save("vgg16Model.h5")

"""# consuming the saved vgg16 model"""

from tensorflow.keras.models import load_model
model = load_model('vgg16Model.h5')

# from google.colab import drive
# drive.mount('/content/drive')

"""#locating the video"""

videoLocation = "./kbsLogFiles/uploads/kbsTest.mp4"

"""#using open cv to create and save frames from uploaded video
#preparing video data for detections predictions 
"""

cap = cv2.VideoCapture(videoLocation)
if not os.path.exists('data'):
    os.makedirs('data')
count = 0

# import os.path.
# save_path = 'C:/example/'
# name_of_file = input("What is the name of the file: ")
# completeName = os.path.join(save_path, name_of_file+".txt")

while(True):
  ret, frame = cap.read()
  #cv2_imshow(frame)
  # ret, frame = cap.read()
  if not ret: 
        break
  if cv2.waitKey(1) & 0xFF == ord('q'):
    break
  name = './kbsLogFiles/frames/' + 'raw' + str(count) + '.jpg'
  print('Framing Vieo ....' + name)
  cv2.imwrite(name, frame)
  count += 1

"""#capturing all frames"""

imagesLocation = "./kbsLogFiles/frames/*.jpg"

images = []
for filename in glob.glob(imagesLocation):
  imageFrame = image.load_img(filename, color_mode='rgb', target_size=(224,224)) 
  images.append(imageFrame)

"""#verifying frame saving"""

images

import streamlit as st

images[66]

glob.glob(imagesLocation)[1]

"""#detecting and predicting on frames and saving data"""

def detectObject():
    # iterating over the frames
    framedArr = []
    for imageItem in images:

    # transforming frames to array    
      imageArray = image.img_to_array(imageItem)

    # expanding dimensions
      imageArray = np.expand_dims(imageArray, axis = 0)

    # preprocessing data    
      imageArray = preprocess_input(imageArray)

    # detecting and predicting from frames
      features = model.predict(imageArray)

    # decoding predictions  
      result = decode_predictions(features)
      framedArr.append(result[0][1][1]) 
    # saving the predicted data
      # cv2.imwrite("./filedata/", features)  
    return framedArr

detectObject()

"""<!-- verify result -->

#Verifying predictions
"""

framedArr[0]

imageArray.shape

imageArray

"""#Search function for video frames"""


def searchFor(object):
    frame_list = detectObject()
    result_list = []
    indexes = []
    for item in frame_list:
        if item.__eq__(object):
            index = frame_list.index(item)
            img = images[index]
            result_list.append(img)
            indexes.append(index)
    return result_list

searchRes = search_for('punching_bag')

"""# displaying search result"""

searchRes[0]

